<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>dns解析过程</title>
      <link href="/2023/12/20/dns/"/>
      <url>/2023/12/20/dns/</url>
      
        <content type="html"><![CDATA[<p>通过 DNS 解析，得到域名的 IP 地址，才能访问网站。</p><p>那么，DNS 解析到底是怎么完成的？本文通过实例，详细介绍背后的步骤。</p><h2 id="一、dns服务器"><a href="#一、dns服务器" class="headerlink" title="一、dns服务器"></a>一、dns服务器</h2><p>域名对应的 IP 地址，都保存在 DNS 服务器。</p><p>我们输入域名，浏览器就会在后台，自动向 DNS 服务器发出请求，获取对应的 IP 地址。这就是 DNS 查询。</p><p><img src="/2023/12/20/dns/2.png" alt="1"></p><p>举例来说，我输入<code>www.baidu.com</code> 这个域名，浏览器就要向 DNS 服务器查询，它的 IP 地址是什么，然后向该 IP 发出访问请求。<br>网上有很多公共 DNS 服务器，这篇文章选择 Google 公司提供的 <code>8.8.8.8</code> 进行演示。</p><h2 id="二、域名的层次结构"><a href="#二、域名的层次结构" class="headerlink" title="二、域名的层次结构"></a>二、域名的层次结构</h2><p>你可能会问，难道 DNS 服务器（比如 <code>8.8.8.8</code>）保存了世界上所有域名（包括二级域名、三级域名）的 IP 地址？</p><p>当然不是。DNS 是一个分布式系统，<code>8.8.8.8</code> 只是用户查询入口，它也需要再向其它 DNS 服务器查询，才能获得最终的 IP 地址。</p><p>要说清楚 DNS 完整的查询过程，就必须了解 <strong>域名是一个树状结构</strong>。</p><p>最顶层的域名是根域名（root），然后是顶级域名（top-level domain，简写 TLD），再是二级域名、三级域名。</p><p><img src="/2023/12/20/dns/5.png" alt="1"></p><p><strong>（1）根域名</strong></p><p>所有域名的起点都是根域名，它写作一个点<code>.</code>，放在域名的结尾。因为这部分对于所有域名都是相同的，所以就省略不写了，比如<code>baidu.com</code>等同于<code>example.com.</code>（结尾多一个点）。</p><p>你可以试试，任何一个域名结尾加一个点，浏览器都可以正常解读。</p><p><strong>（2）顶级域名</strong></p><p>根域名的下一级是顶级域名。它分成两种：通用顶级域名（gTLD，比如 .com 和 .net）和国别顶级域名（ccTLD，比如 .cn 和 .us）。</p><p>顶级域名由国际域名管理机构 ICANN 控制，它委托商业公司管理 gTLD，委托各国管理自己的国别域名。</p><p><strong>（3）二级域名</strong></p><p>二级域名就是你在某个顶级域名下面，自己注册的域名。比如，<code>baidu.com</code>就是在顶级域名<code>.com</code>下面注册的。</p><p><strong>（4）三级域名</strong></p><p>三级域名是二级域名的子域名，是域名拥有者自行设置的，不用得到许可。比如，<code>www</code> 就是 <code>baidu.com</code> 的三级域名。</p><h2 id="三、域名服务器的层次结构"><a href="#三、域名服务器的层次结构" class="headerlink" title="三、域名服务器的层次结构"></a>三、域名服务器的层次结构</h2><p>域名具有层次结构，域名需要服务器进行管理，也有相应的层次结构，上一级域名服务器知道下一级域名服务器的IP地址</p><table><thead><tr><th>分类(由高到低)</th><th>作用</th></tr></thead><tbody><tr><td>根域名服务器</td><td>最高层次的域名服务器，本地域名服务解析不了会向其求助</td></tr><tr><td>顶级域名服务器</td><td>负责管理该顶级域名服务器下注册的二级域名</td></tr><tr><td>权域名服务器</td><td>负责一个区(管理权限的范围)的域名解析工作</td></tr><tr><td>本地域名服务器</td><td>当一个主机发出DNS查询请求时，会首先发给本地域名服务器</td></tr></tbody></table><h3 id="根域名服务器"><a href="#根域名服务器" class="headerlink" title="根域名服务器"></a>根域名服务器</h3><p>根域名服务器是全球DNS系统的核心，它包含所有顶级域名的信息。</p><p>根域名服务器共有13个，以英文字母a到m依序命名，域名格式为<code>字母.root-servers.net</code>，分布在全球各地，通过<a href="https://root-servers.org/%E5%8F%AF%E4%BB%A5%E6%9F%A5%E7%9C%8B%E3%80%82">https://root-servers.org/可以查看。</a></p><table><thead><tr><th><strong>名称</strong></th><th><strong>IPV4地址(IPV6地址)</strong></th><th><strong>管理单位(设置地点)</strong></th></tr></thead><tbody><tr><td>a</td><td>198.41.0.4（2001:503:ba3e::2:30）</td><td>Verisign, Inc.（美国，弗吉尼亚州）</td></tr><tr><td>b</td><td>170.247.170.2（2801:1b8:10::b）</td><td>Information Sciences Institute（美国，加利弗尼亚州）</td></tr><tr><td>c</td><td>192.33.4.12（2001:500:2::c）</td><td>Cogent Communications（美国，弗吉尼亚州）</td></tr><tr><td>d</td><td>199.7.91.13（2001:500:2d::d）</td><td>University of Maryland（美国马里兰州）</td></tr><tr><td>e</td><td>192.203.230.10（2001:500:a8::e）</td><td>NASA Ames Research Center（美国加利弗尼亚州）</td></tr><tr><td>f</td><td>192.5.5.241（2001:500:2f::f）</td><td>Internet Systems Consortium, Inc.（美国加利弗尼亚州）</td></tr><tr><td>g</td><td>192.112.36.4（2001:500:12::d0d）</td><td>Defense Information Systems Agency（美国弗吉尼亚州）</td></tr><tr><td>h</td><td>198.97.190.53（2001:500:1::53）</td><td>U.S. Army DEVCOM Army Research Lab（美国马里兰州）</td></tr><tr><td>i</td><td>192.36.148.17（2001:7fe::53）</td><td>Netnod（瑞典，斯德哥尔摩）</td></tr><tr><td>j</td><td>192.58.128.30（2001:503:c27::2:30)</td><td>Verisign, Inc.（美国，弗吉尼亚州）</td></tr><tr><td>k</td><td>193.0.14.129（2001:7fd::1）</td><td>RIPE NCC（英国，伦敦）</td></tr><tr><td>l</td><td>199.7.83.42（2001:500:9f::42）</td><td>ICANN（美国，弗吉尼亚州）</td></tr><tr><td>m</td><td>202.12.27.33（2001:dc3::35）</td><td>WIDE Project（日本，东京）</td></tr></tbody></table><p>当本地DNS服务器无法处理某个域名请求时，它会向根域名服务器发起请求，获取域名服务器的信息，进而进行下一步的解析。</p><h3 id="顶级域名服务器"><a href="#顶级域名服务器" class="headerlink" title="顶级域名服务器"></a>顶级域名服务器</h3><p>顶级域名服务器存储着所有同一顶级域名（如.com、.org等）下的二级域名（如.baidu.com、google.com等）的DNS信息。顶级域名服务器的数量取决于每个顶级域名的实际情况。</p><h3 id="权威域名服务器"><a href="#权威域名服务器" class="headerlink" title="权威域名服务器"></a>权威域名服务器</h3><p>权威域名服务器存储着各个域名的DNS信息，包括域名解析、记录信息等。当本地DNS服务器无法处理某个域名请求时，它会向权威域名服务器发起请求，获取相应的DNS记录信息。</p><h3 id="本地域名服务器"><a href="#本地域名服务器" class="headerlink" title="本地域名服务器"></a>本地域名服务器</h3><p>本地DNS服务器通常由网络服务提供商（ISP）或企业机构提供，主要负责本地DNS缓存的管理和域名解析的处理。本地DNS服务器会向根域名服务器、顶级域名服务器和权威域名服务器等发起请求，获取DNS信息，并将这些信息缓存到本地以提高DNS解析效率。</p><h2 id="四、域名的逐级查询"><a href="#四、域名的逐级查询" class="headerlink" title="四、域名的逐级查询"></a>四、域名的逐级查询</h2><p>域名树状结构的意义在于，只有上级域名，才知道下一级域名的 IP 地址，需要逐级查询。</p><p>每一级域名都有自己的 DNS 服务器，存放下级域名的 IP 地址。</p><p>所以，如果想要查询三级域名<code>www.baidu.com</code> 的 IP 地址，需要三个步骤。</p><blockquote><p>第一步，查询根域名服务器，获得顶级域名服务器<code>.com</code>（又称 TLD 服务器）的 IP 地址。</p><p>第二步，查询 TLD 服务器 <code>.com</code>，获得权威域名服务器 <code>baidu.com</code> 的 IP 地址。</p><p>第三步，查询权威域名服务器 <code>baidu.com</code>，获得三级域名 <code>www</code> 的 IP 地址。</p></blockquote><p><img src="/2023/12/20/dns/9.png" alt="1"></p><h2 id="五、域名解析过程"><a href="#五、域名解析过程" class="headerlink" title="五、域名解析过程"></a>五、域名解析过程</h2><p>以用户在浏览器中输入<code>www.baidu.com</code>为例，讲一下DNS解析的流程：</p><blockquote><ol><li>浏览器检查自身缓存是否解析过此域名的IP地址，如果存在则解析结束</li><li>当浏览器缓存中没有，会检查操作系统缓存中是否解析过此域名，即系统的hosts文件，如果用户在此文件中配置了域名-IP的映射关系，则解析结束</li><li>当系统hosts文件中没有，则会去请求本地域名服务器(递归查询)解析此域名，如果存在则解析结束(大部分DNS解析在此完成)</li><li>如果本地域名服务器没有，本地域名服务器会向根域名服务器发起请求(迭代查询)，根域名服务器会告诉本地域名服务器，下一步应该查询的顶级域名服务器的IP地址</li><li>本地域名服务器得到IP地址后，向对应IP的顶级域名服务器发起请求进行查询，顶级域名服务器会告诉本地域名服务器，下一步应该查询的权限域名服务器的IP地址</li><li>本地域名服务器得到IP地址后，相对应IP的权限域名服务器发起请求进行查询，权限服务器告诉本地域名服务器所查询的主机的IP地址</li><li>本地域名服务器得到主机IP地址后，把查询结果反馈给主机</li></ol></blockquote><p><img src="/2023/12/20/dns/6.png" alt="1"></p><p>客户端与 LocalDNS 之间的交互，被称为递归查询； LocalDNS 与根&#x2F;顶级域&#x2F;权威 DNS 服务器之间的交互，被称为迭代查询。递归查询和迭代查询的区别是：递归查询是虽然我不知道，但原因我帮你问，你只需要等待最终结果就好了；而迭代查询则是虽然我不知道，但我可以告诉你谁可能知道，你需要自己去问它。</p><h2 id="六、dig常用命令"><a href="#六、dig常用命令" class="headerlink" title="六、dig常用命令"></a>六、dig常用命令</h2><p>命令行工具 dig 可以跟 DNS 服务器互动，可以帮我我们更好的了解dns解析的过程。</p><h4 id="1-从指定dns服务器查询域名解析"><a href="#1-从指定dns服务器查询域名解析" class="headerlink" title="1.从指定dns服务器查询域名解析"></a>1.从指定dns服务器查询域名解析</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">dig @[DNS 服务器] [域名]</span></span><br></pre></td></tr></table></figure><p>向 <code>8.8.8.8</code>查询域名，就执行下面的命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">dig @8.8.8.8 www.baidu.com</span></span><br></pre></td></tr></table></figure><p>在其中找到 ANSWER SECTION 这个部分，它给出了查询的答案，域名对应的 IP 地址是 110.242.68.4。</p><p><img src="/2023/12/20/dns/3.png" alt="1"></p><h4 id="2-dig查询指定IP地址所对应的域名信息（反向查询）"><a href="#2-dig查询指定IP地址所对应的域名信息（反向查询）" class="headerlink" title="2.dig查询指定IP地址所对应的域名信息（反向查询）"></a>2.dig查询指定IP地址所对应的域名信息（反向查询）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">dig -x [ip]</span></span><br></pre></td></tr></table></figure><p>反向解析 <code>110.242.68.3</code>这个ip，就执行下面的命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">dig -x 110.242.68.3</span></span><br></pre></td></tr></table></figure><p><img src="/2023/12/20/dns/7.png" alt="1"></p><h4 id="3-dig查看dns解析详细过程"><a href="#3-dig查看dns解析详细过程" class="headerlink" title="3.dig查看dns解析详细过程"></a>3.dig查看dns解析详细过程</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">dig +trace [域名]</span></span><br></pre></td></tr></table></figure><p>如果要查看 <code>www.baidu.com</code>这个域名dns的详细解析过程，就执行下面的命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">dig +trace www.baidu.com</span></span><br></pre></td></tr></table></figure><p><img src="/2023/12/20/dns/8.png" alt="1"></p><p>Todo补充dig mx ns等</p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dns </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java几种引用类型</title>
      <link href="/2023/05/22/java_reference/"/>
      <url>/2023/05/22/java_reference/</url>
      
        <content type="html"><![CDATA[<h1 id="一-强引用"><a href="#一-强引用" class="headerlink" title="一. 强引用"></a>一. 强引用</h1><p><strong>用途：</strong> 程序中普遍存在的对象<br><strong>回收时机：</strong> 只要强引用还在，垃圾手机器永远不会回收掉被引用的对象。<br><strong>实现：</strong> </p><h1 id="二-软引用"><a href="#二-软引用" class="headerlink" title="二. 软引用"></a>二. 软引用</h1><p><strong>用途：</strong> 有用但非必须的对象<br><strong>回收时机：</strong><br><strong>实现：</strong> 使用SoftReference类实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三-弱引用"><a href="#三-弱引用" class="headerlink" title="三. 弱引用"></a>三. 弱引用</h1><p><strong>用途：</strong> 非必须的对象<br><strong>回收时机：</strong><br><strong>实现：</strong> 使用WeakReference类实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四-虚引用"><a href="#四-虚引用" class="headerlink" title="四. 虚引用"></a>四. 虚引用</h1><p><strong>用途：</strong><br><strong>回收时机：</strong><br><strong>实现：</strong> 使用PhantomReference类实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="扩展1：FinalReference"><a href="#扩展1：FinalReference" class="headerlink" title="扩展1：FinalReference"></a>扩展1：FinalReference</h4><h4 id="扩展2：RefrenceQueue"><a href="#扩展2：RefrenceQueue" class="headerlink" title="扩展2：RefrenceQueue"></a>扩展2：RefrenceQueue</h4>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jvm对象判活的几种方式</title>
      <link href="/2023/05/22/jvm_object_judgment/"/>
      <url>/2023/05/22/jvm_object_judgment/</url>
      
        <content type="html"><![CDATA[<h1 id="一-引用计数法"><a href="#一-引用计数法" class="headerlink" title="一. 引用计数法"></a>一. 引用计数法</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>在对象中添加一个引用计数器，每当有一个地方引用改对象时，计数器+1；当引用失效时，计数器-1。任何时刻计数器为0的对象就是不可能再被使用的。</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>缺点：对象之间如果存在循环引用，会导致引用计数永远都不为0，不会被垃圾回收。</p><p>优点：实现简单，判断效率高</p><h1 id="二-可达性分析法（引用链法）"><a href="#二-可达性分析法（引用链法）" class="headerlink" title="二. 可达性分析法（引用链法）"></a>二. 可达性分析法（引用链法）</h1><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>通过一系列称为“GC Roots”的对象作为起点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明对象是不可用的。</p><h2 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h2><p>优点：解决了对象之间循环引用的问题。</p><h2 id="可以作为GC-Roots的对象"><a href="#可以作为GC-Roots的对象" class="headerlink" title="可以作为GC Roots的对象"></a>可以作为GC Roots的对象</h2><ul><li>虚拟机栈(栈帧中的本地变量表)中引用的对象—-&gt;局部变量</li><li>方法区中类的静态属性引用的对象—-&gt;类静态变量</li><li>方法区中常量引用的对象—-&gt;常量</li><li>本地方法栈中JNI引用的对象—-&gt;native方法</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> java </category>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jvm垃圾回收算法</title>
      <link href="/2023/05/22/jvm_garbage_collection_algorithm/"/>
      <url>/2023/05/22/jvm_garbage_collection_algorithm/</url>
      
        <content type="html"><![CDATA[<h4 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h4><ol><li><p>标记-清除算法<br>原理：首先标记出所有要回收的对象，在标记完成后统一回收所有被标记的对象。<br>优点：最基础的垃圾收集算法<br>缺点：<br> 1.效率问题：标记和清除两个过程的效率都不高。（<strong>原因是什么？</strong>）<br> 2.空间问题：标记清除会产生大量的不连续的内存碎片。当有大对象时，无法找到足够的连续内存存放， 进而触发一次垃圾收集操作。</p></li><li><p>复制算法<br>原理：将内存分成相等大小的2块，每次只使用其中的1块。当这1块内存使用完后，就将活着的对象复制到另1块内存上，然后把已使用过的内存空间一次清理掉。<br>优点：没有空间碎片，实现简单，运行高效。<br>缺点：可用内存变成了原来的一半，空间浪费。</p></li><li><p>标记-整理(标记-压缩)算法<br>原理：首先标记出所有要回收的对象，在标记完成后，首先将所有存活的对象都向一端移动，然后再清理掉端边界以外的内存。<br>优点：不会出现大量的不连续的内存碎片<br>缺点：<br> 1.效率问题：不仅需要标记的过程，再整理过程中，还需要整理存活对象的引用。（对象地址的移动）</p></li><li><p>分代收集算法<br>新生代采用”复制算法”；老年代采用”标记-清理算法”、”标记-整理算法”。</p></li></ol><hr><h4 id="新生代垃圾回收算法"><a href="#新生代垃圾回收算法" class="headerlink" title="新生代垃圾回收算法"></a>新生代垃圾回收算法</h4><h5 id="1-触发Minor-GC-的条件："><a href="#1-触发Minor-GC-的条件：" class="headerlink" title="1. 触发Minor GC 的条件："></a>1. 触发Minor GC 的条件：</h5><ol><li></li></ol><h5 id="2-适用的垃圾回收算法："><a href="#2-适用的垃圾回收算法：" class="headerlink" title="2. 适用的垃圾回收算法："></a>2. 适用的垃圾回收算法：</h5><p>复制算法。</p><hr><h4 id="老年代垃圾回收算法"><a href="#老年代垃圾回收算法" class="headerlink" title="老年代垃圾回收算法"></a>老年代垃圾回收算法</h4><h5 id="1-触发Full-GC-的条件："><a href="#1-触发Full-GC-的条件：" class="headerlink" title="1. 触发Full GC 的条件："></a>1. 触发Full GC 的条件：</h5><ol><li>Minor GC前，如果老年代的可用空间小于新生代全部对象的大小：<ol><li>如果没有开启了空间分配担保，则直接进行Full GC。</li><li>如果开启空间分配担保，</li></ol></li><li>Minor GC后</li><li></li></ol><h5 id="2-适用的垃圾回收算法：-1"><a href="#2-适用的垃圾回收算法：-1" class="headerlink" title="2. 适用的垃圾回收算法："></a>2. 适用的垃圾回收算法：</h5><ol><li>标记-清除算法。</li><li>标记-整理算法。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> java </category>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jvm垃圾收集器</title>
      <link href="/2023/05/22/jvm_garbage_collector/"/>
      <url>/2023/05/22/jvm_garbage_collector/</url>
      
        <content type="html"><![CDATA[<h1 id="jvm垃圾收集器"><a href="#jvm垃圾收集器" class="headerlink" title="jvm垃圾收集器"></a>jvm垃圾收集器</h1><h4 id="Stop-the-world"><a href="#Stop-the-world" class="headerlink" title="Stop the world"></a>Stop the world</h4><p>stop the world：jvm会停止工作线程，只开启垃圾回收线程工作。<br>目的是在进行垃圾回收时，java工作线程不会创建新对象，新生代不会接收到新的对象。</p><p>PS：</p><ol><li>stop the world会造成系统停顿，因为会停止工作线程。</li><li>不同的垃圾收集器 stop the world的影响不同。</li></ol><hr><h4 id="jvm垃圾收集器-1"><a href="#jvm垃圾收集器-1" class="headerlink" title="jvm垃圾收集器"></a>jvm垃圾收集器</h4><h5 id="1-serial垃圾收集器"><a href="#1-serial垃圾收集器" class="headerlink" title="1. serial垃圾收集器"></a>1. serial垃圾收集器</h5><h5 id="2-parNew垃圾收集器"><a href="#2-parNew垃圾收集器" class="headerlink" title="2. parNew垃圾收集器"></a>2. parNew垃圾收集器</h5><h5 id="3-CMS垃圾收集器"><a href="#3-CMS垃圾收集器" class="headerlink" title="3. CMS垃圾收集器"></a>3. CMS垃圾收集器</h5><ol><li>初始标记：只标记</li><li>并发标记</li><li>重新标记</li><li>并发清理</li></ol><p>存在的问题：</p><ol><li>并发垃圾回收，会存在占用CPU资源的问题。</li></ol><h5 id="4-G1垃圾收集器"><a href="#4-G1垃圾收集器" class="headerlink" title="4. G1垃圾收集器"></a>4. G1垃圾收集器</h5>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> java </category>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
